---
·	title: uniapp前置知识与小程序核心语法
date: 2021-10-17 22:00:34
categories:
- uniapp
- 微信小程序
tags:
- uniapp
- 微信小程序

---

# 小程序前置知识与小程序核心语法

## 认识小程序

### 准备工作

根据官网文档进行微信公众平台小程序账号申请：https://mp.weixin.qq.com/

下载[开发工具](https://mp.weixin.qq.com/wxamp/thirdtools/extend?token=792253097&lang=zh_CN)并新建项目

<!--more-->

![image-20211018001905052](https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211018001905052.png)

一定需要注册小程序账号能获得有appId

![image-20211018001806025](https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211018001806025.png)

### 小程序基本概念

#### 小程序的基本组成结构

##### pages 文件夹存小程序的页面

<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211018005832564.png" alt="image-20211018005832564" style="zoom:50%;" />

每个页面对应一个文件夹，包含 index.js，index.json ，index.wxml，index.wxss四个文件，

一个小程序页面也就是由这四个文件组成的 **js,wxml,json,wxss**

| 文件类型                                                     | 必需 | 作用                                               |
| :----------------------------------------------------------- | :--- | :------------------------------------------------- |
| [js](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html) | 是   | 页面逻辑，存放页面存储数据，事件函数，页面生命周期 |
| [wxml](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/) | 是   | 页面结构，页面的模板结构                           |
| [json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#页面配置) | 否   | 页面配置，可以配置当前页面的外观、表现等           |
| [wxss](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html) | 否   | 页面样式表                                         |

##### project.config.json 项目配置文件

项目配置文件，记录对小程序开发工具做的个性化配置

- setting 中保存了 编译相关配置
- projectname 保存了 项目名称
- appid 保存了小程序账号的id

##### sitemap.json 配置是否可以被微信索引

文档https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html"

- rules 配置项指定了索引规则

- action表示命中该规则的页面是否能被索引

##### 其他配置

utils 文件夹是工具类文件夹

app.json 小程序公共配置文件

```json
 // 整个程序的页面路径
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ],
// 窗口的一些表现
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black"
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}
```

### WXML VS HTML

#### 什么是WXML

WXML（WeiXin Markup Language）是框架设计的一套标签语言，用来构建小程序的页面结构，作用类似于网页开发中的HTML

#### WXML和 HTML的区别

1. 标签名不一样

   html： div，span，img，a

   wxml： view，text，image，navigatior（小程序提供的组件）

2. 属性节点不同
   `<a href="#"> 超链接 </a>`

   `  <navigator url="/pages/home/home">跳转到home页</navigator>`

3. 提供了动态渲染数据的模板语法

   - 数据绑定
   - 条件渲染
   - 列表渲染

#### 我是否可以在 wxml 文件中写入 div标签？并说出原因

- 可以写入，但是 **不要**使用 

- 在微信wxml中 div标签会被解析成**类view** 标签效果(h1,div标签都会被解析成类似view标签，原有的属性样式都会被去掉)    

### WXSS VS CSS

1. 什么是WXSS？
   - WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。
   - 类似于网页开发中的CSS
   - WXSS 具有CSS 大部分的特性
2. 新增了尺寸单位 -- "rpx" 一个 rpx 为页面宽度的 1/750 ，微信将页面的宽度分成了750份
3. 提供了全局样式和局部样式
   1. 群居样式 写入到根目录到 wxss 中的样式
   2. 局部样式： 写入到 页面的 wxss中的样式
4. 此外 wxss仅支持部分css 选择器
   1.  .class (推荐使用) 和 #id
   2.  element
   3.  并集选择器和后代选择器
   4.  :: after 和 before 等 伪类选择器



#### wxss 新增了什么尺寸单位

增了尺寸单位 -- **"rpx"** 一个 rpx 为页面宽度的 **1/750**

#### wxss 中推荐使用什么选择器

.class 选择器

### .json 配置文件

小程序中，额外多出了一个 .json 的配置文件，json 文件主要分为两个： 

1. 项目根目录下的 .json 文件

   1. 修改项目的基本配置

      - 例如修改 window条目下的    "navigationBarBackgroundColor": "#00ff00",

2. 页面中的 .json 文件

   1. 修改页面的基本配置（优先级高）
      - 在具体页面中的 页面.json 配置 "navigationBarBackgroundColor": "#fff" 会覆盖项目中的配置

#### 1. 小程序中的 .json 文件主要分为哪几种

- 项目根目录下的 
- 页面中的  .json 文件

#### 2. 当这两种配置文件出现相同配置时，会出现什么结果？

页面中的.json 文件配置优先级更高会覆盖项目根目录中对全局的配置

### 宿主概念与微信小程序的运行环境

#### 什么是宿主环境？

程序运行所依赖的环境 ，

#### 微信小程序项目为什么可以调用微信支付功能？

小程序的宿主环境：手机微信 ，而手机微信提供了对应的功能

#### 小程序的运行环境是如何划分的？

渲染层，逻辑层

![image-20211109161500154](https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211109161500154.png)  

### 小程序的内置组件

可以通过 帮助> 开发者文档 查看小程序提供的组件

![image-20211109161151763](https://gitee.com/laonaiping/blog-images/raw/871963eb321aba5d01d6e692c1a2ef1b33fe7890/img/20211109161216.png)

1. [view](https://developers.weixin.qq.com/miniprogram/dev/component/view.html)

2. [scroll-view](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html)  可滚动视图区域 相当于一个overflow = scroll的div

   使用竖向滚动时，需要给scroll-view一个固定高度/高度，只要超过固定的高/宽度就可以开始滚动行为了

   通过 WXSS 设置 height。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)

3. [swiper](https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html) && [swiper-item](https://developers.weixin.qq.com/miniprogram/dev/component/swiper-item.html) 相当于banner

4. [text](https://developers.weixin.qq.com/miniprogram/dev/component/text.html) && [rich-text](https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html)

5. [button](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)

6. [image](https://developers.weixin.qq.com/miniprogram/dev/component/image.html) 图片。支持 JPG、PNG、SVG、WEBP、GIF 等格式，[2.3.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 起支持云文件ID。

### 小程序成员管理

https://kf.qq.com/faq/170302zeQryI170302beuEVn.html

### 小程序发布流程

![image-20211028060259527](https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211028060259527.png)



分为线上，审核，开发，本地 四个版本

## 小程序核心语法

### 小程序的数据驱动原则

- 什么是数据驱动

  当数据发生变化时，视图理应发生变化

- 小程序中如何完成数据绑定
  - 在.js 文件data 中定义数量
  - 在wxml中通过`{{}}`使用数据

#### 数据驱动：

```js
  // 商品
  let product = {
    price: 10,
    num: 5
  }
  // 总价格
  let total = 0;
  // 计算总价格的方法
  function getTotal(product) {
    return product.price * product.num
  }
  // 计算商品的总价格
  total = getTotal(product)
  // 进行打印
  console.log('总价格：' + total);
  // 50 太贵了，所以我们少购买了两个商品，也就是让 num = 3
  product.num = 3;
  // 问：总价格是多少？
  console.log('总价格：' + total); // 此时，打印发现总价格还是 50 元，如果要说原因的话，那么应该很简单，【因为我们没有重新进行价格的计算嘛】
  // 但是，此时大家有没有想过一点？我们为什么要进行价格的计算呢？
  // ----------------------------------------------------
  // 当商品的数量发生变化时，商品的总价格【理应发生变化】，不是吗？
```

上面的例子，就是我想要跟大家说的：【当数量发生变化时，商品的总价格理应发生改变】。

那么同样的道理，在我们的页面中，假如：

> 某一个 DOM 依赖于某个数据进行展示，那么【当数据发生变化时，视图也理应发生变化】。

而这个就是【响应式数据驱动】。

> PS：如果大家想要跟深入的了解，那么可以查看博客：[聊一聊响应式构建的那些经历](https://www.imooc.com/article/317228)

#### 小程序中完成响应式：

- 在 `data` 中定义数据

  ```js
  // index.js
  // 获取应用实例
  const app = getApp()
  
  Page({
   data: {
     product: {
       price: 10,
       num: 5
     }
   }
  })
  ```

  

- 在 `wxml` 中使用数据

  ```html
  <view>
    <view>
      <!-- wxml 中访问数据，必须使用 {{}} 语法，{{}} 语法中可以放置【任意的、单一的 JavaScript 表达式】 -->  
      商品的单价：{{product.price}}
    </view>
    <view>
      商品的数量：{{product.num}}
    </view>
    <view>
      商品的总价格：{{product.price * product.num}}
    </view>
  </view>
  ```



### 小程序的常用事件与属性列表

#### 按钮添加点击事件

bindtap||bind:tap

我们希望做一件事情：

> 创建一个按钮
>
> 当用户点击按钮时
>
> 让 product 的 num + 1

创建按钮的方式非常简单：

```html
<button type="primary">num + 1</button>
```

问题在于：我们如何给这个按钮添加点击事件呢？

有过开发经验的同学，可能会猜到：我们可以给 `button` 一个 `click` 事件来监听按钮的点击。

可是大家需要知道，现在我们是在【小程序】中，那么如果想要给 `button` 添加点击事件则不可以使用 `click` 而是 **`bind:tap / bindtap`**。

其中 `bind: / bind` 表示【绑定事件】，`tap` 为绑定的具体事件。小程序具体事件列表，可以点击 [这里](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F) 查看。

```html
  <button type="primary" bind:tap="onAddNum">num + 1</button>
```

接下来需要在 `js` 中定义对应的 **事件**

```js
 /**
  * 定义事件处理的方法
  */
 onAddNum () {
  console.log('onAddNum')
 }
```

到目前：我们已经 **监听了按钮的点击事件，并且写入了对应的处理函数** ，接下来就需要 **修改 num 的值 **

#### 修改data中数据的值

- 通过this.setData({}) 定义新的值
- 通过this.data 访问具体的值

想要修改 `data` 中的数据，那么我们需要借助一个函数 `setData`。

`setData` 接收一个 对象作为参数，这个对象就是最新的 `data` 数据。

其中 `key` 为要修改的数据， `value` 为最新的值

**访问 data 的数据：**

因为我们想要让 `num + 1` ，所以我们还需要拿到 `num` 的当前值，想要访问 `num` 的值，可以通过 `this.data.product.num` 的形式访问

所以最终的修改 `num` 的代码为：

```js
 /**
  * 定义事件处理的方法
  */
 onAddNum () {
  this.setData({
    'product.num': this.data.product.num + 1
  })
```

此时，当我们点击 `button` ，可以发现：【当 num 发生改变时，总价格也发生了对应的变化】

### 事件传参

1. 通过属性绑定的形式，把需要传递的参数绑定到当前 DOM 元素的 data-xx 属性下
2. js中通过`e.target.dataset` 访问传递的参数

要借助 **event 对象** 和 **data- 属性** ！

参数的传递包含两个部分：

1. 形参
2. 实参

#### 形参：

首先先来看 **形参**，对于 **点击事件的回调方法** 而言，默认会接收一个参数 **event （事件对象）**。这个 `event` 对象为：**回调方法的唯一参数**

#### 实参：

对于 **小程序** 中，我们不能直接为 **回调方法传递实参**。

而是需要通过：**属性绑定的形式，把需要传递的参数绑定到 当前 `DOM` 元素中**，绑定数据的属性需要以 `data-` 开头。该属性可以通过 `e.target.dataset` 进行访问。

```js
// html
<button type="primary" bind:tap="onAddNum" data-step="5">num + 1</button>

// js
 onAddNum (e) {
  //  获取 data-step 的值
  let step = parseInt(e.target.dataset.step);
  this.setData({
    'product.num': this.data.product.num + step
  })
 }
```



### 双向数据绑定

#### 什么是双向数据绑定

- 当视图发生变化时，数据跟随发生变化
- 当数据发生变化时，视图跟着发生变化

```js
// html
<view>
    商品的数量：
    <!-- 1. 创建一个【数字输入框】 -->
    <!-- 2. 设置 【商品数量】 为输入框的初始值 -->
    <input class="num-input" type="number" value="{{ product.num }}" bindinput="onInput" />
</view>
  
// js
/**
  * 3. 监听 input 的输入事件
  */
 onInput (e) {
  //  4. 获取用户输入的值
   const val = parseInt(e.detail.value);
  //  5. 赋值给【商品数量】
  this.setData({
    'product.num': val
  })


```



### 条件渲染

1. wx:if ... wx:elif ... wx:else 

​    判断结果是true才渲染，false 不渲染

2. hidden

​    结果是true 隐藏，false 不隐藏

  两者区别： 

​    wx:if 条件满足才渲染，否则不渲染

​    hidden： 都会渲染，条件满足则隐藏

​    wxif 切换消耗更高， hidden 初始化消耗更高

​    wxif 适合运行时条件不再改变的情况

​    hidden 适合频繁切换的情况

```html
<!-- wx:if ... wx:elif ... wx:else：判断结果为 true 则进行渲染，否则不进行渲染 -->
  <view>
    售货员小姐姐惊呼：
    <text wx:if="{{ product.price * product.num <= 100 }}">hello 帅哥</text>
    <text wx:elif="{{ product.price * product.num > 100 && product.price * product.num < 1000 }}">哇哦 有钱人哦</text>
    <text wx:else>土豪你好</text>
  </view>
  <!-- hidden：结果为 true 则隐藏，否则不隐藏 -->
  <view>
    售货员小姐姐惊呼：
    <text hidden="{{ !(product.price * product.num <= 100) }}">hello 帅哥</text>
    <text hidden="{{ !(product.price * product.num > 100 && product.price * product.num < 1000) }}">哇哦 有钱人哦</text>
    <text hidden="{{product.price * product.num < 1000}}">土豪你好</text>
  </view>
```



### 列表渲染

- 使用wx:for 当前项的【下标变量名】和【当前项变量名】默认分别是什么？

    默认当前项 item, 默认下标名 index

- block组件是否被渲染?  包裹性值的容器，不会进行渲染 

```js
// html
<!-- 
    利用 wx:for 循环渲染商品
    默认数组的当前项的下标变量名默认为 index，
    数组当前项的变量名默认为 item
   -->
  <view class="product-box">
    <block wx:for="{{ products }}" wx:key="index">
      <view class="product-item">
        <text>商品名：{{item.name}}</text>
        <text>价格：{{item.price}}</text>
      </view>
    </block>
  </view>
  
// js
data: {
   products: [
     {
       name: '苹果',
       price: 3.2
     },
     {
       name: '面包',
       price: 5.0
     },
     {
       name: '可乐',
       price: 2.5
     }
   ]
 }
```



### 配置文件解读

[app.json 配置文件](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)

| 属性                                                         | 类型     | 必填 | 描述                | 最低版本 |
| :----------------------------------------------------------- | :------- | :--- | :------------------ | :------- |
| [entryPagePath](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#entryPagePath) | string   | 否   | 小程序默认启动首页  |          |
| [pages](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#pages) | string[] | 是   | 页面路径列表        |          |
| [window](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#window) | Object   | 否   | 全局的默认窗口表现  |          |
| [tabBar](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar) | Object   | 否   | 底部 `tab` 栏的表现 |          |

- pages

  用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 `.json`, `.js`, `.wxml`, `.wxss` 四个文件进行处理。

  未指定 `entryPagePath` 时，数组的第一项代表小程序的初始页面（首页）。

  **小程序中新增/减少页面，都需要对 pages 数组进行修改。**

  如开发目录为：

  ```text
  ├── app.js
  ├── app.json
  ├── app.wxss
  ├── pages
  │   │── index
  │   │   ├── index.wxml
  │   │   ├── index.js
  │   │   ├── index.json
  │   │   └── index.wxss
  │   └── logs
  │       ├── logs.wxml
  │       └── logs.js
  └── utils
  ```

  则需要在 app.json 中写

  ```json
  {
    "pages": ["pages/index/index", "pages/logs/logs"]
  }
  ```

- window

  用于设置小程序的状态栏、导航条、标题、窗口背景色。

  ![image-20211110145040066](https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211110145040066.png)

  | 属性                         | 类型     | 默认值  | 描述                                                         | 最低版本                                               |
  | :--------------------------- | :------- | :------ | :----------------------------------------------------------- | :----------------------------------------------------- |
  | navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色，如 `#000000`                                 |                                                        |
  | navigationBarTextStyle       | string   | white   | 导航栏标题颜色，仅支持 `black` / `white`                     |                                                        |
  | navigationBarTitleText       | string   |         | 导航栏标题文字内容                                           |                                                        |
  | navigationStyle              | string   | default | 导航栏样式，仅支持以下值： `default` 默认样式 `custom` 自定义导航栏，只保留右上角胶囊按钮。参见注 2。 | iOS/Android 微信客户端 6.6.0，Windows 微信客户端不支持 |
  | backgroundColor              | HexColor | #ffffff | 窗口的背景色                                                 |                                                        |
  | enablePullDownRefresh        | boolean  | false   | 是否开启全局的下拉刷新。 详见 [Page.onPullDownRefresh](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onpulldownrefresh) |                                                        |

- tabbar

  如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。

  ![image-20211110152148817](https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211110152148817.png)

 中 list 接受一个数组，**只能配置最少 2 个、最多 5 个 tab**。tab 按数组的顺序排序，每个项都是一个对象，其属性值如下：

| 属性             | 类型   | 必填 | 说明                                                         |
| :--------------- | :----- | :--- | :----------------------------------------------------------- |
| pagePath         | string | 是   | 页面路径，必须在 pages 中先定义                              |
| text             | string | 是   | tab 上按钮文字                                               |
| iconPath         | string | 否   | 图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 **当 `position` 为 `top` 时，不显示 icon。** |
| selectedIconPath | string | 否   | 选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 **当 `position` 为 `top` 时，不显示 icon。** |

[页面的配置文件](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)

页面的配置和全局的window配置有很多相似的，页面的配置会覆盖全局配置

### 数据请求

[wx.request](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html) 发起网络请求，请求的方式主要分为两种：

1. get 请求
2. post 请求

根据 [wx.request](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html) 来完成一个基本的接口请求

```js
// html
<view>
  <button type="primary" bindtap="onGetClick">发起 get 请求</button>
</view>
// js
// index.js
// 获取应用实例
onGetClick () {
    wx.request({
        url: 'https://api.imooc-blog.lgdsunday.club/api/test/getList',
        method: 'GET',
        success: (res) => {
            console.log(res);
        }
    })
}

```

这样的代码看起来没有任何问题，但是我们却得到了一个错误<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211111142121127.png" alt="image-20211111142121127" style="zoom:50%;" />

而要解决这个问题，我们就需要明确一个问题：**小程序中的数据请求有什么限制？**

1. 只能请求 `HTTPS` 类型的接口
2. 必须将接口的域名添加到信任列表中(小程序开发后台可以配置)

**解决方案：**

1. 生产环境：将想要请求的域名协议【更改为 HTTPS】并【添加到域名信任列表】

2. 开发环境：

   点击右上角详情 <img src="https://gitee.com/laonaiping/blog-images/raw/master/img/Xnip2021-11-11_14-43-27.jpg" alt="Xnip2021-11-11_14-43-27" style="zoom:50%;" />

   勾选<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211111141111292.png" alt="image-20211111141111292" style="zoom:50%;" />

当 `get` 请求完成，接下来来测试一下 `post` 请求：

```js
// html 
  <button type="primary" bindtap="onPostClick">发起 post 请求</button>
  // js
   onPostClick () {
    wx.request({
      url: 'https://api.imooc-blog.lgdsunday.club/api/test/postData',
      method: 'POST',
      data: {
        msg: '愿大家心想事成，万事如意'
      },
      success: (res) => {
        console.log(res);
      }
    })
  }
```



**题外话（扩展内容：针对有 web 前端开发经验的同学）：**

1. **跨域问题：** 跨域问题主要针对 **浏览器** 而言，而小程序宿主环境为【微信小程序客户端】，所以小程序中不存在【跨域问题】
2. **`ajax` 请求：** `ajax` 依赖于 `XMLHttpRequest` 对象，而小程序宿主环境为【微信小程序客户端】，所以小程序中的【网络请求】**不是** `ajax` 请求

#### 问题

> 1. 小程序中的数据请求有什么限制？以及如何解决这种限制
>    1. 限制：
>       1. 只能请求 `HTTPS` 类型的接口
>       2. 必须将接口的域名添加到信任列表中
>    2. 解决方案：
>       1. 生产环境：将想要请求的域名协议【更改为 HTTPS】并【添加到域名信任列表】
>       2. 开发环境：通过勾选![image-20210508103939068](https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210508103939068.png)
> 2. 小程序的数据请求会存在跨域问题吗？为什么？
>    1. 不会
>   3. 【跨域问题】只存在于基于浏览器的 `Web` 开发中
>    4. 由于小程序的宿主环境不是浏览器，而是微信客户端
>    5. 所以小程序中不存在跨域问题
> 6. 小程序的数据请求可以叫做 `ajax` 请求吗？为什么？
>    1. 不可以
>    2. `ajax` 的核心是依赖于 【浏览器端】 的 `XMLHttpRequest` 对象
>    3. 由于小程序的宿主环境不是浏览器，而是微信客户端
>    4. 所以小程序的数据请求不可以叫做 `ajax` 请求

### 异步编程新方案 - promise

首先先去假设一个场景：

> 目前有一个需求，需要你按照以下的逻辑去进行接口请求：
>
> 1. 先去请求接口 A
> 2. 在接口 A 获取到数据之后，再去请求接口 B
> 3. 在接口 B 获取到数据之后，再去请求接口 C
> 4. 在接口 C 获取到数据之后，再去请求接口 D

如果按照上一小节学习到的内容，那么我们会得到以下的代码

```js
   A(function (res) {
    console.log(res);
    B(function (res) {
      console.log(res);
      C(function (res) {
        console.log(res);
        D(function (res) {
          console.log(res);
        })
      })
    })
  })
```

在这个 **颜值即正义** 的世界里面，我们这样的代码结构应该是 **没有前途的**。 因为它太丑了，并且太难以阅读了。

假想一下，如果我们要请求 10 个接口的话，那么代码会变成什么样子？

所以在编程圈里对这样的代码有一个非常学术的名字：**回调地狱** -> 回调函数的大量嵌套导致出现 **复杂且难以阅读** 的逻辑

#### 问题

> 1. promise 是如何解决回调地狱的问题呢？
> 2. Promise 的状态分为几种，分别是什么？
> 3. 如何让 Promise 变成 已兑现（fulfilled）的状态，如何接收已兑现（fulfilled）的结果

#### 内容

点击 [Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise) 进入官方文档：

```js
<!-- 
  使用 Promise 进行定义接口：
  Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。
  它一个构造函数，所以可以通过 new 关键字来构建它，获取实例。
  在 Promise 中，分为了三种状态：
  1. 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。
  2. 已兑现（fulfilled）: 意味着操作成功完成。
  3. 已拒绝（rejected）: 意味着操作失败。
  
  可以通过 promise 实例的 
  1. 成功：promise.then()
  2. 失败：promise.catch() 
  3. 结束：promise.finally()
  的三个方法，进行链式调用来解决回调地狱的问题。
 -->
<script>
  const isA = true
  const isB = true
  const isC = true
  const isD = true

  function A() {
    // 1. 创建 Promise 实例
    return new Promise((resolve, reject) => {
      // 2. 当前处于 【待定（pending）】 状态下
      console.log('执行 A 接口的逻辑')
      setTimeout(() => {
        if (isA) {
          // 3. 进入 【已兑现（fulfilled）】 状态下
          resolve('接口 A 执行完成')
        } else {
          // 4. 进入 【已拒绝（rejected）】 状态下
          reject('接口 A 执行失败')
        }
      }, 1000)
    })
  }

  function B() {
    return new Promise((resolve, reject) => {
      console.log('执行 B 接口的逻辑')
      setTimeout(() => {
        if (isB) {
          resolve('接口 B 执行完成')
        } else {
          reject('接口 B 执行失败')
        }
      }, 1000)
    })
  }

  function C() {
    return new Promise((resolve, reject) => {
      console.log('执行 C 接口的逻辑')
      setTimeout(() => {
        if (isC) {
          resolve('接口 C 执行完成')
        } else {
          reject('接口 C 执行失败')
        }
      }, 1000)
    })
  }

  function D() {
    return new Promise((resolve, reject) => {
      console.log('执行 D 接口的逻辑')
      setTimeout(() => {
        if (isD) {
          resolve('接口 D 执行完成')
        } else {
          reject('接口 D 执行失败')
        }
      }, 1000)
    })
  }

  // 获取 Promise 实例
 // 在 .then 中可以继续return 一个promise的实例
// 这个return的实例可以在下一次的.then中接收结果 
  A()
    // 通过 .then 方法获取当前 Promise 的执行结果
    .then(res => {
      console.log(res);
      // 标记下一步进入 B 方法
      return B()
    })
    // 继续 .then 进行下一次的异步操作
    .then(res => {
      console.log(res);
      // 标记下一步进入 C 方法
      return C()
    })
    // 继续 .then 进行下一次的异步操作
    .then(res => {
      console.log(res);
      // 标记下一步进入 D 方法
      return D()
    })
    // 继续 .then 进行下一次的异步操作
    .then(res => {
      console.log(res);
      // 结束
    })
```



**Promise 与 回调地狱的结果代码对比截图**

<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210508152109839.png" alt="image-20210508152109839" style="zoom:80%;" />

#### 答案

> 1. promise 是如何解决回调地狱的问题呢？
>    1. 通过 `.then` 的方式进行 **链式调用**
> 2. Promise 的状态分为几种，分别是什么？
>    1. 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。
>    2. 已兑现（fulfilled）: 意味着操作成功完成。
>    3. 已拒绝（rejected）: 意味着操作失败。
> 3. 如何让 Promise 变成 已兑现（fulfilled）的状态，如何接收已兑现（fulfilled）的结果
>    1. 通过 `resolve` 可以把 `Promise` 的状态，从 【待定（pending）】转变为 【已兑现（fulfilled）】
>    2. 通过 `promise实例.then` 方法可以接收 已兑现（fulfilled） 的结果

但是看到这里之后，可能还会有很多同学 **充满疑惑**， “ 我并不感觉 `promise` 的这种方式更加简单呀？ ”，如果你确实有这样的 **疑问** 的话，那么你应该相信这样的疑问在之前也被人提出过。

那么这个问题是怎么解决的呢？请看下一节 **异步编程再升级 - async + await**

### 异步编程再升级 - async + await

#### 场景

`Promise` 的方案解决了 **回调地狱** 的问题，但是 `Promise` 又带来了新的问题，那就是：**大量的链式调用，让我们的代码变得又臭又长！**

我们回过头看一下 `promise` 和 **回调地狱** 两种方案的代码对比：

<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210508152109839.png" alt="image-20210508152109839" style="zoom:80%;" />

可以发现：**回调地狱 `11` 行的代码**，在 `promise` 中足足花了 `18` 行才解决，代码量足足多了 `60%`。

这种 **“退步”** 是绝对不可以被接受的。那么针对这么一种情况，我们就需要使用到两个新的关键字 `async + await`。

#### 内容

点击 [async](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function)  + [await](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await) 进入官方文档：

```JS
  // 使用 async 和 awiat 可以简化 Promise 的异步操作，把 Promise 的异步操作变为同步写法
  // async：标记一个函数为异步函数
  // await：标记当前操作为异步操作，await 关键字只能使用在被 【async标记的函数中】
  async function test() {
    // 可以直接用这种形式接收 A().then 的结果
    const resA = await A();
    console.log(resA);
    const resB = await B();
    console.log(resB);
    const resC = await C();
    console.log(resC);
    const resD = await D();
    console.log(resD);
  }
```

**三种实现方案截图对比：**

![image-20211111163118503](https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211111163118503.png)



#### 问题

> 1. `async` 和 `await` 的作用是什么？
> 2. 使用 `await` 的注意事项是什么？

#### 答案

> 1. `async` 和 `await` 的作用是什么？
>    1. `async` 和 `await` 可以简化  `promise` 操作
>    2. 使 `promise` 的异步操作拥有 **同步写法**
> 2. 使用 `await` 的注意事项是什么？
>    1. `await` 必须在被 `async` 标记的函数中使用

### 小程序中使用 promise 解决异步编程

#### 场景

回过头来来看【小程序的代码】，同时回顾一下之前我们解决过的需求：

> 目前有一个需求，需要你按照以下的逻辑去进行接口请求：
>
> 1. 先去请求接口 A
> 2. 在接口 A 获取到数据之后，再去请求接口 B
> 3. 在接口 B 获取到数据之后，再去请求接口 C
> 4. 在接口 C 获取到数据之后，再去请求接口 D

这是我们在学习 `promise` 时所列举的场景，那么这个场景同样适用于【小程序】中的【网络请求场景】。如果我们通过 `wx.request` 实现以上需求的话，那么会得到如下代码：

```js
wx.request({
      url: 'A',
      method: 'GET',
      success: (res) => {
        wx.request({
          url: 'B',
          method: 'GET',
          success: (res) => {
            wx.request({
              url: 'C',
              method: 'GET',
              success: (res) => {
                wx.request({
                  url: 'D',
                  method: 'GET',
                  success: (res) => {
                    console.log(res);
                  }
                })
              }
            })
          }
        })
      }
    })
```

一个又臭又长的代码，对不对。

那么接下来我们需要做的就很简单了，我们要 **使用 async 和 await ** 简化以上操作。

#### 内容

如果要达到我们的目标，那么我们需要分成两步来去操作：

1. 获取到 `promise` 实例对象
2. 使用 `async` 和 `await` 简化 `promise` 的操作

**获取到 `promise` 实例对象：**

因为 `wx.request` 不支持 `promise` 化，所以我们需要：**使用 `promise` 封装 `wx.request` 请求**

```js
  pA () {
    return new Promise((resolve, reject) => {
      console.log('执行 A 接口的逻辑');
      wx.request({
        url: 'https://api.imooc-blog.lgdsunday.club/api/test/A',
        success: (res) => {
          resolve(res)
        },
        fail: (err) => {
          reject(err)
        }
      })
    })
  }
```

**使用 `async` 和 `await` 简化 `promise` 的操作（PS：注意不要勾选 ES6 转 ES5）**

```js
async onPromiseGetClick () {
    const resA = await this.pA()
    console.log(resA.data.data.msg);
    const resB = await this.pB()
    console.log(resB.data.data.msg);
    const resC = await this.pC()
    console.log(resC.data.data.msg);
    const resD = await this.pD()
    console.log(resD.data.data.msg);
  }
```

#### 问题

> 1. 如何使 `wx.request` 配合 `async` 和 `await` 使用？



#### 答案

> 1. 如何使 `wx.request` 配合 `async` 和 `await` 使用？
>    1. 使用 `promise` 封装 `wx.request` 请求
>    2. 使用 `async` 和 `await` 简化 `promise` 的操作

### 生命周期

**生命周期** 就是：一件事物由 **创建** 到 **销毁** 的全过程。

在这个过程中会有很多 **” 关键的时刻 “**，这些关键的时刻就是 **生命周期函数**

在 【小程序】中，生命周期主要分为两部分：

1. **页面的生命周期**
2. **组件的生命周期**

下面只介绍页面的生命周期：

创建新的页面 `list`，在新创建的页面中，我们可以发现在 `js` 文件中已经默认生成了很多的代码：

```js
// pages/list/list.js
Page({
	...
    /**
     * 生命周期函数--监听页面加载
     */
    onLoad: function (options) {
        console.log('onLoad');
    },

    /**
     * 生命周期函数--监听页面初次渲染完成
     */
    onReady: function () {
        console.log('onReady');
    },

    /**
     * 生命周期函数--监听页面显示
     */
    onShow: function () {
        console.log('onShow');
    },

    /**
     * 生命周期函数--监听页面隐藏
     */
    onHide: function () {
        console.log('onHide');
    },

    /**
     * 生命周期函数--监听页面卸载
     */
    onUnload: function () {
        console.log('onUnload');
    },
	...
})
```

在这些代码中，我们重点关注 **生命周期函数--xx** 相关的内容。

这 5 个函数，就是 【小程序中的生命周期函数】，我们把鼠标放入到【函数上】，那么【小程序开发工具】会提示出对应的【函数解释】。

**这些生命周期函数不需要全部掌握**，我们只需要着重掌握其中两个就可以：

1. `onLoad`：最先被调用，可以用来【接收别的页面传递过来的数据】。在后面的【页面跳转】中会再去进行讲解。
2. `onReady`：页面初次渲染完成后调用。我们可以 **在这里从服务端获取数据** 

那么知道了这个之后，回到我们最初的需求上，我们希望 **页面出现之后，可以获取接口数据，并进行渲染**。 那么怎么去进行实现呢？

很简单！**只需要在 `onReady` 中调用获取接口数据的方法就可以了**。

那么现在 **我们已经在页面出现之后，获取到了接口的数据**，所以接下来我们只需要根据数据完成页面的渲染就可以了：



```js
// html
<scroll-view class="list-box" scroll-y>
    <block wx:for="{{ listData }}" wx:key="index">
        <view class="list-item">{{ index }} -- {{ item.title }}</view>
    </block>
</scroll-view>

// js
    /**
     * 生命周期函数--监听页面初次渲染完成
     */
    onReady: async function () {
        console.log('onReady');
        const data = await this.getList()
        this.setData({
            listData: data.list
        })
    },
    getList() {
        return new Promise((resolve, reject) => {
            wx.request({
                url: 'https://api.imooc-blog.lgdsunday.club/api/test/getList',
                method: 'GET',
                success: (res) => {
                    resolve(res.data.data)
                }
            })
        })
    }
// css
.list-item {
    padding: 26px;
    font-size: 20px;
    font-weight: bold;
    border-bottom: 1px solid #cccccc;
}
```

#### 问题

> 1. 什么是生命周期？什么是生命周期函数？
> 2. `onReady`  的调用时机是什么？

#### 答案

> 1. 什么是生命周期？什么是生命周期函数？
>    1. 所谓 **生命周期** 就是：一件事物由 **创建** 到 **销毁** 的全过程。
>    2. 在这个过程中会有很多 **” 关键的时刻 “**，这些关键的时刻就是 **生命周期函数**
> 2. `onReady`  的调用时机是什么？
>    1. 页面初次渲染完成后调用。我们可以 **在这里从服务端获取数据** 

### pullToRefresh - 下拉刷新与上拉加载

#### 场景

在现在我们已经实现了 **基本的页面渲染**，但是这样还是不够的。

因为在我们最终的成型项目中， **数据列表是分页进行展示的**。

所谓分页就是：**当列表中数据过多时，一次性加载所有的数据回导致请求过慢，所以前端就会分页来加载数据。**

这种分页的方式在移动端项目上都有大量的体现，比如 【今日头条】、【淘宝】、【微信的聊天记录】等等很多。

那么如果我们想要在当前项目中实现【分页请求】，就需要借助【下拉刷新于上拉加载】的功能，也就是 `pullToRefresh`

#### 问题

> 1. 如何开启下拉刷新
> 2. 在 `onPullDownRefresh` 中，一般进行什么操作
> 3. 在 `onReachBottom` 中，一般进行什么操作

#### 内容

整个【分页加载】分为两个部分：

1. 上拉加载
2. 下拉刷新

这两部分需要分别来进行处理，首先我们先来看【上拉加载】

**上拉加载：**

在 【小程序】中，默认已经实现了【上拉加载】的功能，可以直接通过监听 `onReachBottom` 函数，来监听：**页面上拉触底事件**。当页面滑动到底部时，会触发 `onReachBottom` 函数。

```js
	/**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom: function () {
        console.log('onReachBottom');
    },
```

在【用户上拉】时，我们希望获取【下一页】的数据，所以我们需要对当前的数据进行分页：

```js
    /**
     * 页面的初始数据
     */
    data: {
        // 当前页数
        page: 1,
        // 每页的数据量
        size: 10
    },
```

然后【当页面进入时】，我们获取第一页的数据，所以我们需要对代码进行一下修改：

```js
    getList() {
        return new Promise((resolve, reject) => {
            wx.request({
                url: 'https://api.imooc-blog.lgdsunday.club/api/test/getList',
                method: 'GET',
                // 请求当前页的数据
                data: {
                    page: this.data.page,
                    size: this.data.size
                },
                success: (res) => {
                    resolve(res.data.data)
                }
            })
        })
    }
```

然后在【上拉操作】时，持续进行后续的数据请求：

```js
    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom: async function () {
        console.log('onReachBottom');
        // 修改 page
        this.setData({
            page: this.data.page + 1
        })
        // 获取最新数据
        const data = await this.getList()
        // 将最新的数据补充到现有数据的后面
        this.setData({
          // es6语法：拼接两个数组
            listData: [...this.data.listData, ...data.list]
        })
    },
```

同时我们希望 **数据加载完成后，给用户一个提示，同时不在发起数据请求**

```js
// html
    <!-- 底线 -->
    <view class="bottom" wx:if="{{ listData.length === total }}">-- 我也是有底线的！ --</view>
// js
data: {
    // 总数据量
    total: -1
},
onReady: async function () {
    const data = await this.getList()
    this.setData({
        listData: data.list,
        // 为总数据量赋值
        total: data.total
    })
},
/**
* 页面上拉触底事件的处理函数
*/
onReachBottom: async function () {
    console.log('onReachBottom');
    // 如果当前数据量已经 === 总数据量，则表示数据已经加载完成了
    if (this.data.listData.length === this.data.total) {
        return;
    }
    ...
}
```

那么到目前，我们已经完成了【上拉加载】的操作，但是我们知道，我们还缺少一个【下拉刷新】的操作！

**大家如果看到这里已经感觉代码量很大了，那么可以先暂停一下，把以上代码实现一遍，完成之后，继续往下去看！**

----

**下拉刷新：**

想要在【小程序】中实现【下拉刷新】不同于上拉加载，需要**首先开启**【下拉刷新】：

```json
// 页面.json
{
  "backgroundColor": "#cccccc",
  "enablePullDownRefresh": true
}
```

当我们开启了【下拉刷新】之后，我们就可以去监听 `onPullDownRefresh` 函数，这个函数会在：**用户下拉刷新时进行回调**

```js
    /**
     * 页面相关事件处理函数--监听用户下拉动作
     */
    onPullDownRefresh: function () {
        console.log('onPullDownRefresh');
    },
```

在此回调中，我们需要进行的操作就非常简单了，我们只需要：**重置页数，重置数据源，关闭下拉动画** 就可以了：

```js
/**
     * 页面相关事件处理函数--监听用户下拉动作
     */
    onPullDownRefresh: async function () {
        console.log('onPullDownRefresh');
        // 重置页数
        this.setData({
            page: 1
        })
         // 获取最新数据
         const data = await this.getList()
         // 将最新的数据补充到现有数据的后面
         this.setData({
             listData: data.list
         })
        //  关闭下拉刷新的动作（在真机中，下拉刷新动作不会自动关闭）
        wx.stopPullDownRefresh()
    },
```

#### 答案

> 1. 如何开启下拉刷新
>    1. 对 **页面对应的 `json` 文件** 中通过 `"enablePullDownRefresh": true` 开启
> 2. 在 `onPullDownRefresh` 中，一般进行什么操作
>    1. 重置页数
>    2. 重置数据源
>    3. 关闭下拉动画
> 3. 在 `onReachBottom` 中，一般进行什么操作
>    1. 判断数据是否已经加载完成
>    2. 自增页数
>    3. 累加数据

### 页面跳转 

#### 场景

我们现在已经把【数据列表】全部展示出来了，然后接下来我们需要完成【文章详情页的渲染】，也就是点击【`item` 跳转到文章详情页面】

#### 内容

小程序的页面跳转分为两种方式：

1. 声明式导航
   1. 跳转到 `tabbar` 页面
   2. 跳转到 `非tabbar` 页面
   3. 后退页面
2. 编程式导航
   1. 跳转到 `tabbar` 页面
   2. 跳转到 `非tabbar` 页面
   3. 后退页面

**声明式导航：**

【小程序】中提供了一个：**跳转页面的组件 `navigator`** ，使用这个组件可以完成【声明式导航】

```html
<!-- 跳转到 非 tabbar 页面 -->
<block wx:for="{{ listData }}" wx:key="index">
        <view class="list-item">
            <!-- 注意：url 的表达式必须为 / 开头的页面路径 -->
            <navigator url="/pages/detail/detail">{{ index }} -- {{ item.title }}</navigator>
        </view>
    </block>

----

<!-- 跳转到 tabbar 页面 -->
<!-- 注意：跳转到 tabbar 页面，必须要指定 open-type="switchTab"-->
<navigator open-type="switchTab" url="/pages/index/index">跳转到首页</navigator>

-----

<!-- 后退页面 -->
<!-- 注意：后退页面必须指定 open-type="navigateBack" -->
<navigator open-type="navigateBack">后退</navigator>
```

**编程式导航：**

【小程序】中提供了三个 `API` ，用来帮助我们进行 **编程式导航**：

1. [wx.switchTab](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html)：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面

   ```js
   <!-- 编程式导航跳转到首页 -->
   <button type="primary" bindtap="onSwitchToHome">利用 switchTab 跳转到首页</button>
   
   onSwitchToHome () {
       wx.switchTab({
           url: '/pages/index/index',
       })
   }
   ```

   

2. [wx.navigateTo](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html)：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面

   ```js
   <!-- 编程式导航跳转到详情页面 -->
   <button type="primary" bindtap="onNavigateToDetail">利用 navigateTo 进入详情页</button>
   
   onNavigateToDetail () {
       wx.navigateTo({
           url: '/pages/detail/detail',
       })
   }
   ```

   

3. [wx.navigateBack](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html)：关闭当前页面，返回上一页面或多级页面。

   ```js
   <!-- 编程式导航后退页面 -->
   <button type="primary" bindtap="onNavigateBack">利用 navigateBack 后退页面</button>
   
   onNavigateBack () {
       wx.navigateBack({
           delta: 1,
       })
   }
   ```

   

**导航传参：**

【小程序】的导航传参遵循：**`get` 请求的标准** 。

> 1. 以 `?` 分割 `url` 和参数
> 2. 以 `=` 连接参数的 `key` 和 `value`
> 3. 以 `&` 来拼接参数

那么下面我们来完成案例的最后一个功能：**点击跳转时，传递当前 `item` 的索引和标题，并且在 `detail` 页面中展示**：

```js
// 声明式导航传递参数
<navigator url="/pages/detail/detail?index={{index}}&title={{item.title}}">{{ index }} -- {{ item.title }}</navigator>
// 编程式导航传递参数
<button type="primary" bindtap="onNavigateToDetail" data-index="{{index}}" data-title="{{item.title}}">利用 navigateTo 进入详情页</button>
onNavigateToDetail (e) {
    const { index, title } = e.target.dataset
    wx.navigateTo({
        url: `/pages/detail/detail?index=${index}&title=${title}`,
    })
}
// 在 detail 中接收数据，并展示
<view class="msg">index：{{index}} -- title：{{title}}</view>
onLoad: function (options) {
    const {index, title} = options;
    this.setData({
        index,
        title
    })
}

```

#### 问题

> 1. 页面跳转的方式有哪几种？
> 2. 跳转到 【tabbar】页面和【非 tabbar】页面的方式分别是什么？
> 3. 如何进行导航传参

#### 答案

> 1. 页面跳转的方式有哪几种？
>    1. 声明式导航
>    2. 编程式导航
> 2. 跳转到 【tabbar】页面和【非 tabbar】页面的方式分别是什么？
>    1. 声明式导航
>       1.  `<navigator open-type="switchTab" url="xx" />`
>       2.  `<navigator open-type="navigate"(默认可不指定) url="xx" />`
>    2. 编程式导航
>       1. `wx.switchTab({ url: 'xx'})`
>       2. `wx.navigateTo({ url: 'xx'})`
> 3. 如何进行导航传参
>    1. 【小程序】的导航传参遵循：**`get` 请求的标准** 。
>
>       1. 以 `?` 分割 `url` 和参数
>       2. 以 `=` 连接参数的 `key` 和 `value`
>       3. 以 `&` 来拼接参数



### 小结

1. 数据驱动原则：**由数据来驱动视图** 是 **现代前端开发的核心思想之一**
2. 商品案例：
   1. 数据驱动
   2. 组件的事件处理
   3. 处理事件方法传递参数
   4. 双向数据绑定
   5. 条件渲染
   6. 列表渲染
3. 列表展示案例：
   1. 利用配置文件生成 `tabbar` 
   2. 数据请求的限制
   3. 如何封装 `promise` 的数据请求
   4. 利用 `async + await` 简化异步请求
   5. 页面的生命周期概念
   6. 实现 `pullToRefresh`
   7. 页面跳转

## 组件概念

### 创建第一个组件

#### 场景

> 对于这个案例，我们把它拆成两个部分：
>
> 1. 顶部的 tabs 
> 2. 底部的 list
>
> 两个部分，将分别通过两个组件来进行开发。

所以，我们接下来要做的第一件事情，就是【创建这两个组件，并在页面中使用它们】，而这个也就是本小节的主要内容

#### 内容

1. 创建组件
   1. 创建 `components` 文件夹
   2. 创建 `tabs` 和 `list` 文件夹
   3. 右键 **新建 `Component`**
2. 使用组件
   1. 找到页面的 `.json` 文件
   2. 在 `usingComponents` 选项下 **注册组件**
      1. `key` 为当前组件在该页面中的标签名
      2. `value` 为组件的代码路径
   3. 在页面的 `wxml` 文件中，以 **注册的 `key`** 为标签名，使用组件

#### 问题

> 1. 组件应该被放入到哪个文件夹中？
> 2. 如何在页面中使用【自定义组件】？

#### 答案

> 1. 组件应该被放入到哪个文件夹中？
>    1. components
> 2. 如何在页面中使用【自定义组件】？
>    1. 在页面的 `.json` 文件中，通过 `usingComponents` 进行注册
>    2. 在 `wxml` 文件中，以注册的 `key`  为 **标签名** 进行使用

### 组件的生命周期

#### 场景

接下来我们希望在 `tabs` 组件被渲染之后，获取 `tabs` 的数据，并且进行渲染。

参考下，上一大章中的 `列表案例` ，那么要完成这个功能，我们就必须要有一个 **前置条件：**

那就是：**明确组件的生命周期函数，明确在什么时候去获取接口数据** 

#### 内容

**组件** 的生命周期应该被定义在 `lifetimes` 中，而方法必须要放入到 `methods` 中。

组件的生命周期一共有三个：

1. `created` ： 组件实例刚刚被创建好。**此时还不能调用 `setData`**
2. `attached`：组件完全初始化完毕、进入页面节点树后。**绝大多数初始化工作可以在这个时机进行**
3. `detached`：在组件离开页面节点树后

```js

    /**
     * 组件的初始数据
     */
    data: {
        // 数据源
        listData: [],
        // 选中项
        active: -1
    },
  /**
     * 生命周期函数
     */
    lifetimes: {
        attached() {
            this.loadTabsData()
        }
    },
    /**
     * 组件的方法列表（组件中的方法必须定义到 methods 中）
     */
    methods: {
        /**
         * 获取数据的方法
         */
        loadTabsData() {
            wx.request({
                url: 'https://api.imooc-blog.lgdsunday.club/api/hot/tabs',
                success: (res) => {
                    this.setData({
                        listData: res.data.data.list,
                        active: 0
                    })
                }
            })
        }
    }

<scroll-view class="tabs-box" scroll-x>
    <view wx:for="{{ listData }}" wx:key="index" class="tab {{ active === index ? 'active' : '' }}">
        {{item.label}}
    </view>
</scroll-view>
.tabs-box {
    /* 指定宽度 + 不换行 */
    width: 750rpx;
    white-space: nowrap;
    border-bottom: 1px solid #cccccc;
}

.tab {
    /* 指定 display */
    display: inline-block;
    padding: 12px 22px;
}

.active {
    color: #f94d2a;
}
```



#### 问题

> 1. 组件的 生命周期 和 方法 分别应该被放入到哪个节点下？
> 2. `created` 函数中可以调用 `setData` 吗？
> 3. 获取数据的操作应该在哪个函数中进行？

#### 答案

> 1. 组件的 生命周期 和 方法 分别应该被放入到哪个节点下？
>    1. 生命周期应该被定义在 `lifetimes` 中
>    2. 方法必须要放入到 `methods` 中
> 2. `created` 函数中可以调用 `setData` 吗？
>    1. 不可以
> 3. 获取数据的操作应该在哪个函数中进行？
>    1. `attached`

### 数据监听器

#### 场景

通过 **接口文档** 我们可以看出，如果想要获取 `list` 那么我们需要传递一个 `type` 的参数，而这个 `type` 就是用户选中的 `tab 项` 的 `id`

所以接下来我们就需要来做一件事情：监听用户选中的 `tab`，根据用户选中的 `tab` 来切换底部 `list` 的数据

#### 内容

目标：**监听用户选中的 `tab`，根据用户选中的 `tab` 来切换底部 `list` 的数据**

当我们面临一个复杂的需求时，我们需要把 **复杂的需求，拆解为几个可执行的步骤**

大家看到这里，可以先思考一下，我们如何拆解以上需求...

步骤拆解如下：

> 1. 监听用户选中项的变化
> 2. 获取用户选中的数据的 `id`
> 3. 把 `id` 传递给 `list` 组件
> 4. `list` 组件根据接收到的 `id` 获取对应的数据

```js
<view wx:for="{{ listData }}" wx:key="index" class="tab {{ active === index ? 'active' : '' }}" bindtap="onItemClick" data-index="{{index}}">
        {{item.label}}
    </view>
        /**
         * 1. 监听用户选中项的变化
         * item 点击事件处理
         */
        onItemClick(e) {
            // 1.1：获取用户选中的 下标
            const {
                index
            } = e.target.dataset;
            // 1.2：修改选中项
            this.setData({
                active: index
            })
        }


  /**
     * 1.3：监听 active 的变化
     * 通过 observers 定义数据监听器
     */
    observers: {
        // key 为要监听的数据
        // value 为当数据发生变化时，调用的函数
        active: function (active) {
            // 2：获取用户选中的数据的 `id`
            const {id} = this.data.listData[active]
        }
    }
```

到目前，我们已经实现了需求的前两步，那么后面的两步怎么做呢？

请查看我们下一章：**组件之间的关系与通讯**

#### 问题

> 1. 小程序中通过哪个选项来声明数据监听器
> 2. 数据监听器的使用场景是什么？

#### 答案

> 1. 小程序中通过哪个选项来声明数据监听器
>    1. `observers`
> 2. 数据监听器的使用场景是什么？（需要同学自己思考）
>    1. 需要监听数据的变化
>    2. 在数据变化之后，进行一些操作的时候

### 组件之间的关系与通讯

#### 场景

> 1. 监听用户选中项的变化
> 2. 获取用户选中的数据的 `id`
> 3. 把 `id` 传递给 `list` 组件
> 4. `list` 组件根据接收到的 `id` 获取对应的数据

在上一节中，我们实现了前面两步，但是接下来当我们想要把 `id` 传递给 `list` 组件的时候，却遇到了一些问题。我们不知道如何才能 **在一个组件中把数据传递给另外一个组件** ，那么这一小节我们就来去解决这个问题。

#### 内容

**组件之间的关系：**

组件之间的关系和 `html` 标签之间的关系其实是相同的：

1. 父子关系 ![image-20210513101931968](https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210513103334265.png)
2. 兄弟关系 ![image-20210513101957706](https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210513103334265.png)

**不同关系之间的传递数据方式：**

1. 父子关系

   1. 父向子传参：

      ```
      // 子组件：通过 properties 声明要从父组件中接收的数据
          /**
           * 组件的属性列表
           */
          properties: {
              tabId: String
          },
      
      // 父组件：通过自定义属性的形式传递数据，以子组件中定义的 key 为属性名，以要传递的数据为属性值
         <list tabId="{{tabSelectId}}">
      ```

   2. 子向父传参：

      ```js
      // 子组件：通过 triggerEvent 方法发送一个通知，通知父组件接收数据。
      // 方法的第一个参数为：通知名
      // 方法的第二个参数为：要传递的数据
      this.triggerEvent('change', {
          id
      })
      
      // 父组件：通过 bind 监听子组件中发送的通知
      // bind 后的内容为 子组件发送的通知名，表达式为接收到该通知时所触发的方法
      <tabs bind:change="onTabChange"></tabs>
      // 方法被触发后可以通过 e.detail 的形式获取子组件传递过来的数据对象
      onTabChange (e) {
          const {id} = e.detail;
          this.setData({
              tabSelectId: id
          })
      }
      ```

      

2. 兄弟关系

   1. 兄弟组件之间传参：**兄弟关系 === 没有关系**。 兄弟组件只是为了方便称呼的一个叫法而已。 ![image-20210513103334265](https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210513103334265.png)

      所以想要完成兄弟组件之间的传参，就需要：**为它们建立关系。**

      而建立关系说白了就是为了找到一个：**和这两个组件都认识的 ”中间人“ 。** 

      这个中间人一般为：**统一的父组件。**

      而最后：兄弟组件之间想要传递数据，就需要利用 ”中间人进行传递“，也就是：

      > 1. 【兄弟 A 组件】传递数据给 父组件（中间人）
      > 2. 父组件（中间人）再把数据传递给 【兄弟 B 组件】



#### 问题

> 1. 组件之间数据传递的关系可以分为哪几种？
> 2. 兄弟组件之间传递数据的方式是什么？

#### 答案

> 1. 组件之间数据传递的关系可以分为哪几种？
>    1. 父向子传递数据
>    2. 子向父传递数据
>    3. 兄弟组件之间传递数据
> 2. 兄弟组件之间传递数据的方式是什么？

### 组件的插槽

#### 场景

整个案例还剩下最后一个功能：在列表的头部和尾部分别展示文本。

而这个功能我们有一个额外的要求：具体展示的文本和样式，我们需要在父组件中指定。

因为，组件可以进行复用，当 `list` 组件应用到 `index` 时，我们展示的文本和样式，并不一定为在其他页面时想要展示的文本和样式。所以这个文本和样式不可以在 `list` 中写死。

那么要实现这个功能就需要使用到 **插槽** 的知识了。

#### 问题

> 1. 什么时候需要使用插槽？
> 2. 小程序中如何定义多个插槽？

#### 内容

**1：定义：**

**1.1：定义单一插槽：**

在 **组件** 中使用 `slot` 组件定义插槽。

表示：占据了这一块空间，等待父组件填充。

**1.2：定义多个插槽：**

小程序默认只能定义一个插槽，如果要定义多个插槽那么需要：**在组件中指定 `options` 选项的 `multipleSlots` 选项为 `true`**

然后通过 `slot` 的 `name` 属性为插槽命名。例如：`<slot name="header"></slot>`

**2：使用：**

**2.1：使用单一插槽：**

在组件使用时，以 `innerHTML` 的形式插入内容：

```
<component>
    <view>单一插槽插入的 DOM</view>
</component>
```

**2.2：使用多个插槽：**

在组件使用时，以 `innerHTML` 的形式插入内容，以 `slot` 属性标记当前 `DOM` 插入到哪个插槽中：

```
<component>
    <view slot="header">该元素将被插入到 name=header 的插槽中</view>
    <view slot="footer">该元素将被插入到 name=footer 的插槽中</view>
</component>
```



#### 答案

> 1. 什么时候需要使用插槽？
>    1. 由 父组件 来指定 子组件 中某一部分展示的内容和样式时
> 2. 小程序中如何定义多个插槽？
>    1. 指定 `options` 的 `multipleSlots` 为 `true`

### 本章小结

1. 创建组件
2. 组件的生命周期nis
3. 数据监听器
4. 组件的关系
5. 组件的通讯
6. 组件的插槽

