---
title: 排序（上）
date: 2021-03-30 16:52:10
categories:
- 数据结构与算法
 - 排序
tags:
- 数据结构与算法
 - 排序
---

# Geek时间：排序（上）笔记

## 如何分析一个“排序算法”？

### 排序算法的执行效率

​	对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：

#### 1. 最好情况、最坏情况、平均情况（均摊）时间复杂度

​	我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。为什么要区分这三种时间复杂度呢？	第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。

​	第二，对于要排序的数据，有的接近有序，有的完全无序。

有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

#### 2. 时间复杂度的系数、常数 、低阶

​	我们知道，时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

### 排序算法的内存消耗

​	我们前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，**原地排序**（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

### 排序算法的稳定性

​	仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，***稳定性***。这个概念是说，**如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变**。

## 原地排序（Sorted in place）

​	原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。我们今天讲的三种排序算法，都是原地排序算法。

### 冒泡排序 （Bubble Sort）

​	冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。

​	一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

​	例子：我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样：

<img src="排序（上）/image-20210330175008885.png" alt="image-20210330175008885" style="zoom:50%;" />

​	可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。

<img src="排序（上）/image-20210330174943352.png" alt="image-20210330174943352" style="zoom:50%;" />

​	实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。

<img src="排序（上）/image-20210330175527494.png" alt="image-20210330175527494" style="zoom:50%;" />

```java
   public static int[] bubbleSort(int[] arr) {
        int n = arr.length;
        // 需要比较的次数（i<length）
        for (int i = 0; i < n; ++i) {
            // 提前退出冒泡循环的标志位
            boolean flag = false;
            //j<n-i-1 自己可以加回来的 在比较过程中会使用i+1,所以最大长度是length -i-1
            for (int j = 0; j < n - i - 1; ++j) {
                if (arr[j] > arr[j + 1]) { // 交换
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                    flag = true;  // 表示有数据交换
                }
            }
            if (!flag) break;  // 没有数据交换，提前退出
        }
        return arr;
    }
```

#### 第一，冒泡排序是原地排序算法吗？

​	冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。

#### 第二，冒泡排序是稳定的排序算法吗？

​	在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。第

#### 三，冒泡排序的时间复杂度是多少？

​	最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。



### 插入排序（Insertion Sort）